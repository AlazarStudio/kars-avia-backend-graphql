// –ò–º–ø–æ—Ä—Ç Prisma –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö –∏ PubSub –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ —Å–æ–±—ã—Ç–∏–π –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
import { prisma } from "../../prisma.js"
import { GraphQLError } from "graphql"
import GraphQLUpload from "graphql-upload/GraphQLUpload.mjs"
import { uploadImage } from "../../exports/uploadImage.js"
import { uploadFiles } from "../../exports/uploadFiles.js"
import { pubsub } from "../../exports/pubsub.js"
import {
  allMiddleware,
  superAdminMiddleware
} from "../../middlewares/authMiddleware.js"

// –†–µ–∑–æ–ª—å–≤–µ—Ä –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ (support) —á–∞—Ç–æ–≤.
// –≠—Ç–æ—Ç —Ä–µ–∑–æ–ª—å–≤–µ—Ä –æ—Ç–≤–µ—á–∞–µ—Ç –∑–∞ –ø–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —á–∞—Ç–æ–≤ –ø–æ–¥–¥–µ—Ä–∂–∫–∏, —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —á–∞—Ç–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è,
// –∞ —Ç–∞–∫–∂–µ –∑–∞ –ø–æ–∏—Å–∫ —á–∞—Ç–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∏, —Å–≤—è–∑–∞–Ω–Ω–æ–≥–æ —Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º.
const supportResolver = {
  Upload: GraphQLUpload,

  Query: {
    getAllPatchNotes: async (_, __, context) => {
      await allMiddleware(context)
      return await prisma.patchNote.findMany({
        orderBy: { date: "desc" }
      })
    },

    getAllDocumentations: async (_, __, context) => {
      await allMiddleware(context)
      return await prisma.documentation.findMany({
        orderBy: { name: "desc" },
        include: { children: true, parent: true }
      })
    },

    getPatchNote: async (_, { id }, context) => {
      await allMiddleware(context)
      return await prisma.patchNote.findUnique({
        where: { id }
      })
    },

    getDocumentation: async (_, { id }, context) => {
      await allMiddleware(context)
      const doc = await prisma.documentation.findUnique({ where: { id } })
      if (!doc) throw new GraphQLError("–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
      return doc
    },
    documentationTree: async (_, { id }, context) => {
      await allMiddleware(context) // –ø—Ä–æ–≤–µ—Ä–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
      const tree = await buildDocumentationTree(id)
      return tree // –≤–æ–∑–≤—Ä–∞—â–∞–µ–º JSON
    },
    // Query: supportChats
    // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —á–∞—Ç–æ–≤ –ø–æ–¥–¥–µ—Ä–∂–∫–∏.
    // –î–æ—Å—Ç—É–ø —Ä–∞–∑—Ä–µ—à—ë–Ω —Ç–æ–ª—å–∫–æ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, —É –∫–æ—Ç–æ—Ä—ã—Ö —Å–≤–æ–π—Å—Ç–≤–æ support –∑–∞–¥–∞–Ω–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä, —ç—Ç–æ –∞–≥–µ–Ω—Ç –ø–æ–¥–¥–µ—Ä–∂–∫–∏).
    // –ö–∞–∂–¥—ã–π —á–∞—Ç –≤–∫–ª—é—á–∞–µ—Ç —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ (participants) —Å –¥–∞–Ω–Ω—ã–º–∏ –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ –∏ —Å–æ–æ–±—â–µ–Ω–∏—è (messages).
    supportChats: async (_, __, context) => {
      await allMiddleware(context)
      const { user } = context

      // –ï—Å–ª–∏ —É —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ—Ç –ø—Ä–∞–≤ –ø–æ–¥–¥–µ—Ä–∂–∫–∏, –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ–º –æ—à–∏–±–∫—É
      if (!user.support) {
        throw new Error("Access denied")
      }
      // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤—Å–µ —á–∞—Ç—ã, –ø–æ–º–µ—á–µ–Ω–Ω—ã–µ –∫–∞–∫ support (isSupport: true), —Å –≤–∫–ª—é—á–µ–Ω–∏–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –∏ —Å–æ–æ–±—â–µ–Ω–∏–π
      return await prisma.chat.findMany({
        where: { isSupport: true },
        include: {
          participants: {
            include: {
              user: {
                select: {
                  id: true,
                  name: true,
                  number: true,
                  images: true,
                  role: true,
                  position: true,
                  airlineId: true,
                  airlineDepartmentId: true,
                  hotelId: true,
                  dispatcher: true
                }
              }
            }
          },
          messages: true
        }
      })
    },

    // Query: userSupportChat
    // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —á–∞—Ç –ø–æ–¥–¥–µ—Ä–∂–∫–∏, —Å–≤—è–∑–∞–Ω–Ω—ã–π —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º userId.
    // –ï—Å–ª–∏ —á–∞—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω, —Å–æ–∑–¥–∞–µ—Ç—Å—è –Ω–æ–≤—ã–π —á–∞—Ç –ø–æ–¥–¥–µ—Ä–∂–∫–∏, –≤ –∫–æ—Ç–æ—Ä—ã–π –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è —É–∫–∞–∑–∞–Ω–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏ –≤—Å–µ –∞–≥–µ–Ω—Ç—ã –ø–æ–¥–¥–µ—Ä–∂–∫–∏.
    userSupportChat: async (_, { userId }, context) => {
      await allMiddleware(context)
      // –ò—â–µ–º —á–∞—Ç –ø–æ–¥–¥–µ—Ä–∂–∫–∏, –≥–¥–µ —Å—Ä–µ–¥–∏ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º userId
      let chat = await prisma.chat.findFirst({
        where: {
          isSupport: true,
          participants: { some: { userId } }
        },
        include: {
          participants: {
            include: {
              user: {
                select: {
                  id: true,
                  name: true,
                  number: true,
                  images: true,
                  role: true,
                  position: true,
                  airlineId: true,
                  airlineDepartmentId: true,
                  hotelId: true,
                  dispatcher: true
                }
              }
            }
          },
          messages: true
        }
      })
      // –ï—Å–ª–∏ —á–∞—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω, —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π
      if (!chat) {
        // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∏–º–µ—é—â–∏—Ö —Ñ–ª–∞–≥ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ (support: true)
        const supportUsers = await prisma.user.findMany({
          where: { support: true }
        })
        if (supportUsers.length === 0) {
          throw new Error("No support agents available")
        }
        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —á–∞—Ç –ø–æ–¥–¥–µ—Ä–∂–∫–∏, –¥–æ–±–∞–≤–ª—è—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –≤—Å–µ—Ö –∞–≥–µ–Ω—Ç–æ–≤ –ø–æ–¥–¥–µ—Ä–∂–∫–∏
        chat = await prisma.chat.create({
          data: {
            isSupport: true,
            participants: {
              create: [
                { user: { connect: { id: userId } } },
                ...supportUsers.map((support) => ({
                  user: { connect: { id: support.id } }
                }))
              ]
            }
          },
          include: {
            participants: {
              include: {
                user: {
                  select: {
                    id: true,
                    name: true,
                    number: true,
                    images: true,
                    role: true,
                    position: true,
                    airlineId: true,
                    airlineDepartmentId: true,
                    hotelId: true,
                    dispatcher: true
                  }
                }
              }
            },
            messages: true
          }
        })
      }
      return chat
    }
  },

  Mutation: {
    createPatchNote: async (_, { data, images }, context) => {
      await superAdminMiddleware(context)

      let imagePaths = []
      if (images && images.length > 0) {
        for (const image of images) {
          const uploadedPath = await uploadImage(image)
          imagePaths.push(uploadedPath)
        }
      }

      return await prisma.patchNote.create({
        data: { data, imagePaths }
      })
    },

    updatePatchNote: async (_, { id, data, images }, context) => {
      await superAdminMiddleware(context)

      let imagePaths = []
      if (images && images.length > 0) {
        for (const image of images) {
          const uploadedPath = await uploadImage(image)
          imagePaths.push(uploadedPath)
        }
      }

      return await prisma.patchNote.update({
        where: { id },
        data: { data, imagePaths }
      })
    },

    createDocumentation: async (_, { data: input, images }, context) => {
      await superAdminMiddleware(context)

      const data = prepareCreateInput(input)

      let imagePaths = []
      if (images && images.length > 0) {
        for (const image of images) {
          const uploadedPath = await uploadImage(image)
          imagePaths.push(uploadedPath)
        }
      }

      if (!data.name) {
        throw new GraphQLError("–ü–æ–ª–µ 'name' –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ")
      }

      return await prisma.documentation.create({
        data: { data, images: imagePaths /*files: filePath*/ },
        include: { children: true, parent: true }
      })
    },
    updateDocumentation: async (_, { id, data, images }, context) => {
      await superAdminMiddleware(context)
      const exists = await prisma.documentation.findUnique({ where: { id } })
      if (!exists) throw new GraphQLError("–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

      if (data.parentId && data.parentId === id) {
        throw new GraphQLError("–≠–ª–µ–º–µ–Ω—Ç –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Å–≤–æ–∏–º –∂–µ —Ä–æ–¥–∏—Ç–µ–ª–µ–º")
      }

      if (input.parentId) {
        const descendants = await getDescendantIds(id)
        if (descendants.includes(input.parentId)) {
          throw new GraphQLError(
            "–ù–µ–ª—å–∑—è —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ—Ç–æ–º–∫–∞ –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Ä–æ–¥–∏—Ç–µ–ª—è"
          )
        }
      }

      let imagePaths = []
      if (images && images.length > 0) {
        for (const image of images) {
          const uploadedPath = await uploadImage(image)
          imagePaths.push(uploadedPath)
        }
      }

      return await prisma.documentation.update({
        where: { id },
        data: { data, imagePaths }
      })
    },
    // üîÅ –ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç
    moveDocumentation: async (_, { id, newParentId, newOrder }, context) => {
      await superAdminMiddleware(context)
      const doc = await prisma.documentation.findUnique({ where: { id } })
      if (!doc) throw new GraphQLError("–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

      // üõë –°–∞–º —Å–µ–±–µ —Ä–æ–¥–∏—Ç–µ–ª—å
      if (newParentId === id) {
        throw new GraphQLError("–≠–ª–µ–º–µ–Ω—Ç –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Å–≤–æ–∏–º –∂–µ —Ä–æ–¥–∏—Ç–µ–ª–µ–º")
      }

      // üõë –ü–æ—Ç–æ–º–æ–∫ –∫–∞–∫ —Ä–æ–¥–∏—Ç–µ–ª—å
      if (newParentId) {
        const descendants = await getDescendantIds(id)
        if (descendants.includes(newParentId)) {
          throw new GraphQLError(
            "–ù–µ–ª—å–∑—è —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ—Ç–æ–º–∫–∞ –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Ä–æ–¥–∏—Ç–µ–ª—è"
          )
        }
      }

      // 1. –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ—Ö —Å–æ—Å–µ–¥–µ–π –Ω–æ–≤–æ–≥–æ —Ä–æ–¥–∏—Ç–µ–ª—è, –∫—Ä–æ–º–µ —Ç–µ–∫—É—â–µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
      const siblings = await prisma.documentation.findMany({
        where: {
          parentId: newParentId ?? null,
          NOT: { id }
        },
        orderBy: { order: "asc" }
      })

      // 2. –í—Å—Ç–∞–≤–ª—è–µ–º –Ω–∞—à —ç–ª–µ–º–µ–Ω—Ç –Ω–∞ –ø–æ–∑–∏—Ü–∏—é newOrder, –æ—Å—Ç–∞–ª—å–Ω—ã–º ‚Äî —Å–¥–≤–∏–≥
      const reordered = [
        ...siblings.slice(0, newOrder),
        { ...doc, id }, // –≤—Ä–µ–º–µ–Ω–Ω–æ –≤—Å—Ç–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â–∏–π, –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏
        ...siblings.slice(newOrder)
      ]

      // 3. –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ—Ä—è–¥–æ–∫ —É –≤—Å–µ—Ö
      const updatePromises = reordered.map((item, index) => {
        return prisma.documentation.update({
          where: { id: item.id },
          data: { order: index }
        })
      })

      await Promise.all(updatePromises)

      // 4. –û–±–Ω–æ–≤–ª—è–µ–º parentId (–æ—Ç–¥–µ–ª—å–Ω–æ, –µ—Å–ª–∏ –æ–Ω –∏–∑–º–µ–Ω–∏–ª—Å—è)
      const updated = await prisma.documentation.update({
        where: { id },
        data: {
          parentId: newParentId ?? null
        }
      })

      return updated
    },
    deleteDocumentation: async (_, { id }) => {
      await superAdminMiddleware(context)
      const exists = await prisma.documentation.findUnique({ where: { id } })
      if (!exists) throw new GraphQLError("–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

      // –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: –∫–∞—Å–∫–∞–¥–Ω–æ —É–¥–∞–ª–∏—Ç—å –¥–µ—Ç–µ–π ‚Äî –Ω–µ –∑–∞–±—É–¥—å, —á—Ç–æ Prisma –Ω–µ –¥–µ–ª–∞–µ—Ç —ç—Ç–æ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
      const children = await prisma.documentation.findMany({
        where: { parentId: id }
      })
      if (children.length > 0) {
        throw new GraphQLError("–°–Ω–∞—á–∞–ª–∞ —É–¥–∞–ª–∏—Ç–µ –¥–æ—á–µ—Ä–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã")
      }

      await prisma.documentation.delete({ where: { id } })
      return true
    },
    createSupportChat: async (_, { userId }, context) => {
      await allMiddleware(context)
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ —á–∞—Ç –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ userId
      const existingChat = await prisma.chat.findFirst({
        where: {
          isSupport: true,
          participants: { some: { userId } }
        }
      })

      if (existingChat) {
        return existingChat
      }

      // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π-–∞–≥–µ–Ω—Ç–æ–≤ –ø–æ–¥–¥–µ—Ä–∂–∫–∏
      const supportUsers = await prisma.user.findMany({
        where: { support: true }
      })

      if (supportUsers.length === 0) {
        throw new Error("No support agents available")
      }

      // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —á–∞—Ç –ø–æ–¥–¥–µ—Ä–∂–∫–∏ —Å —É—á–∞—Å—Ç–Ω–∏–∫–∞–º–∏: —É–∫–∞–∑–∞–Ω–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏ –≤—Å–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∏–µ –∞–≥–µ–Ω—Ç—ã
      const chat = await prisma.chat.create({
        data: {
          isSupport: true,
          participants: {
            create: [
              { user: { connect: { id: userId } } },
              ...supportUsers.map((support) => ({
                user: { connect: { id: support.id } }
              }))
            ]
          }
        },
        include: {
          participants: {
            include: {
              user: {
                select: {
                  id: true,
                  name: true,
                  number: true,
                  images: true,
                  role: true,
                  position: true,
                  airlineId: true,
                  airlineDepartmentId: true,
                  hotelId: true,
                  dispatcher: true
                }
              }
            }
          }
        }
      })

      return chat
    }
  },
  Documentation: {
    parent: async (doc) => {
      if (!doc.parentId) return null
      return await prisma.documentation.findUnique({
        where: { id: doc.parentId }
      })
    },
    children: async (doc) => {
      return await prisma.documentation.findMany({
        where: { parentId: doc.id },
        orderBy: { order: "asc" }
      })
    }
  }
}

// —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ –ø–æ–ª—É—á–∞–µ–º –≤—Å–µ—Ö –ø–æ—Ç–æ–º–∫–æ–≤
async function getDescendantIds(id) {
  const children = await prisma.documentation.findMany({
    where: { parentId: id }
  })
  let ids = children.map((c) => c.id)
  for (const child of children) {
    const childDescendants = await getDescendantIds(child.id)
    ids = ids.concat(childDescendants)
  }
  return ids
}

async function buildDocumentationTree(id) {
  const rootDoc = await prisma.documentation.findUnique({
    where: { id },
    select: {
      id: true,
      parentId: true,
      name: true,
      description: true,
      type: true,
      order: true,
      files: true
    }
  })

  if (!rootDoc) return null

  const children = await prisma.documentation.findMany({
    where: { parentId: rootDoc.id },
    select: {
      id: true,
      parentId: true,
      name: true,
      description: true,
      type: true,
      order: true,
      files: true
    },
    orderBy: { order: "asc" }
  })

  const childrenTree = await Promise.all(
    children.map((child) => buildDocumentationTree(child.id))
  )

  return { ...rootDoc, children: childrenTree }
}

function prepareCreateInput(node) {
  if (!node || typeof node !== "object") return {}

  const { children, ...rest } = node

  const cleaned = {
    ...rest,
    children:
      Array.isArray(children) && children.length > 0
        ? {
            create: children
              .map(prepareCreateInput)
              .filter((child) => child && child.name)
          }
        : undefined
  }

  return cleaned
}

export default supportResolver
